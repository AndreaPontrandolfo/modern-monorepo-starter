"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBuildConfigs = void 0;
const tslib_1 = require("tslib");
const fs = (0, tslib_1.__importStar)(require("fs-extra"));
const constants_1 = require("./constants");
const createRollupConfig_1 = require("./createRollupConfig");
const logError_1 = (0, tslib_1.__importDefault)(require("./logError"));
const utils_1 = require("./utils");
// check for custom dts.config.js
let dtsBuildConfig = {
    rollup(config, _options) {
        return config;
    },
};
if (fs.existsSync(constants_1.paths.appConfigTs)) {
    try {
        require('ts-node').register({
            compilerOptions: {
                module: 'CommonJS',
            },
        });
        dtsBuildConfig = (0, utils_1.interopRequireDefault)(require(constants_1.paths.appConfigTs)).default;
    }
    catch (error) {
        (0, logError_1.default)(error);
        process.exit(1);
    }
}
else if (fs.existsSync(constants_1.paths.appConfigJs)) {
    dtsBuildConfig = require(constants_1.paths.appConfigJs);
}
async function createBuildConfigs(opts, appPackageJson) {
    const allInputs = createAllFormats(opts).map((options, index) => (Object.assign(Object.assign({}, options), { 
        // We want to know if this is the first run for each entryfile
        // for certain plugins (e.g. css)
        writeMeta: index === 0 })));
    return await Promise.all(allInputs.map(async (options, index) => {
        // pass the full rollup config to dts-cli.config.js override
        const config = await (0, createRollupConfig_1.createRollupConfig)(appPackageJson, options, index);
        return dtsBuildConfig.rollup(config, options);
    }));
}
exports.createBuildConfigs = createBuildConfigs;
function createAllFormats(opts) {
    const sharedOpts = Object.assign(Object.assign({}, opts), { 
        // for multi-entry, we use an input object to specify where to put each
        // file instead of output.file
        input: opts.input.reduce((dict, input, index) => {
            dict[`${opts.output.file[index]}`] = input;
            return dict;
        }, {}), 
        // multiple UMD names aren't currently supported for multi-entry
        // (can't code-split UMD anyway)
        name: Array.isArray(opts.name) ? opts.name[0] : opts.name });
    return [
        opts.format.includes('cjs') && Object.assign(Object.assign({}, sharedOpts), { format: 'cjs', env: 'development' }),
        opts.format.includes('cjs') && Object.assign(Object.assign({}, sharedOpts), { format: 'cjs', env: 'production' }),
        opts.format.includes('esm') && Object.assign(Object.assign({}, sharedOpts), { format: 'esm' }),
        opts.format.includes('umd') && Object.assign(Object.assign({}, sharedOpts), { format: 'umd', env: 'development' }),
        opts.format.includes('umd') && Object.assign(Object.assign({}, sharedOpts), { format: 'umd', env: 'production' }),
        opts.format.includes('system') && Object.assign(Object.assign({}, sharedOpts), { format: 'system', env: 'development' }),
        opts.format.includes('system') && Object.assign(Object.assign({}, sharedOpts), { format: 'system', env: 'production' }),
    ].filter(Boolean);
}
